
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repair: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mnohosten/laura-db/pkg/repair/repair.go (79.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package repair

import (
        "fmt"
        "time"

        "github.com/mnohosten/laura-db/pkg/database"
        "github.com/mnohosten/laura-db/pkg/document"
)

// IssueType represents the type of issue found during validation
type IssueType string

const (
        IssueTypeMissingID           IssueType = "missing_id"
        IssueTypeInvalidID           IssueType = "invalid_id"
        IssueTypeOrphanedIndexEntry  IssueType = "orphaned_index_entry"
        IssueTypeMissingIndexEntry   IssueType = "missing_index_entry"
        IssueTypeDuplicateUnique     IssueType = "duplicate_unique"
        IssueTypeCorruptDocument     IssueType = "corrupt_document"
        IssueTypeInvalidIndexOrder   IssueType = "invalid_index_order"
        IssueTypeIndexFieldMismatch  IssueType = "index_field_mismatch"
)

// Issue represents a problem found during validation
type Issue struct {
        Type        IssueType
        Severity    string // "critical", "warning", "info"
        Collection  string
        DocumentID  string
        IndexName   string
        Description string
        Details     map[string]interface{}
}

// ValidationReport contains the results of a validation run
type ValidationReport struct {
        StartTime     time.Time
        EndTime       time.Time
        Collections   []string
        Issues        []Issue
        DocumentCount int64
        IndexCount    int64
        IsHealthy     bool
}

// RepairReport contains the results of a repair operation
type RepairReport struct {
        StartTime    time.Time
        EndTime      time.Time
        Issues       []Issue
        Fixed        int
        Failed       int
        FixedIssues  []Issue
        FailedIssues []Issue
}

// RepairOptions controls how repair operations are performed
type RepairOptions struct {
        // RebuildIndexes will rebuild all indexes from scratch
        RebuildIndexes bool

        // RemoveOrphans will remove orphaned index entries
        RemoveOrphans bool

        // AddMissingEntries will add missing index entries
        AddMissingEntries bool

        // UniqueConflictResolution: "first", "last", "fail"
        UniqueConflictResolution string

        // DryRun will perform validation but not make changes
        DryRun bool
}

// DefaultRepairOptions returns safe default options
func DefaultRepairOptions() *RepairOptions <span class="cov8" title="1">{
        return &amp;RepairOptions{
                RebuildIndexes:           false,
                RemoveOrphans:            true,
                AddMissingEntries:        true,
                UniqueConflictResolution: "fail",
                DryRun:                   false,
        }
}</span>

// Validator validates database integrity
type Validator struct {
        db *database.Database
}

// NewValidator creates a new validator for the given database
func NewValidator(db *database.Database) *Validator <span class="cov8" title="1">{
        return &amp;Validator{
                db: db,
        }
}</span>

// Validate performs a full database validation
func (v *Validator) Validate() (*ValidationReport, error) <span class="cov8" title="1">{
        report := &amp;ValidationReport{
                StartTime:   time.Now(),
                Collections: make([]string, 0),
                Issues:      make([]Issue, 0),
                IsHealthy:   true,
        }

        // Get all collections
        collections := v.db.ListCollections()
        report.Collections = collections

        // Validate each collection
        for _, collName := range collections </span><span class="cov8" title="1">{
                coll := v.db.Collection(collName)
                if coll == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Validate documents
                <span class="cov8" title="1">docIssues, docCount := v.validateDocuments(coll)
                report.Issues = append(report.Issues, docIssues...)
                report.DocumentCount += int64(docCount)

                // Validate indexes
                indexIssues, indexCount := v.validateIndexes(coll)
                report.Issues = append(report.Issues, indexIssues...)
                report.IndexCount += int64(indexCount)</span>
        }

        // Determine overall health
        <span class="cov8" title="1">for _, issue := range report.Issues </span><span class="cov0" title="0">{
                if issue.Severity == "critical" </span><span class="cov0" title="0">{
                        report.IsHealthy = false
                        break</span>
                }
        }

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}

// ValidateCollection validates a specific collection
func (v *Validator) ValidateCollection(collectionName string) (*ValidationReport, error) <span class="cov8" title="1">{
        report := &amp;ValidationReport{
                StartTime:   time.Now(),
                Collections: []string{collectionName},
                Issues:      make([]Issue, 0),
                IsHealthy:   true,
        }

        coll := v.db.Collection(collectionName)
        if coll == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collection not found: %s", collectionName)
        }</span>

        // Validate documents
        <span class="cov8" title="1">docIssues, docCount := v.validateDocuments(coll)
        report.Issues = append(report.Issues, docIssues...)
        report.DocumentCount = int64(docCount)

        // Validate indexes
        indexIssues, indexCount := v.validateIndexes(coll)
        report.Issues = append(report.Issues, indexIssues...)
        report.IndexCount = int64(indexCount)

        // Determine overall health
        for _, issue := range report.Issues </span><span class="cov0" title="0">{
                if issue.Severity == "critical" </span><span class="cov0" title="0">{
                        report.IsHealthy = false
                        break</span>
                }
        }

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}

// validateDocuments checks document integrity
func (v *Validator) validateDocuments(coll *database.Collection) ([]Issue, int) <span class="cov8" title="1">{
        issues := make([]Issue, 0)

        // Get all documents
        docs, err := coll.Find(map[string]interface{}{})
        if err != nil </span><span class="cov0" title="0">{
                issues = append(issues, Issue{
                        Type:        IssueTypeCorruptDocument,
                        Severity:    "critical",
                        Collection:  coll.Name(),
                        Description: fmt.Sprintf("Failed to retrieve documents: %v", err),
                })
                return issues, 0
        }</span>

        // Check each document
        <span class="cov8" title="1">for _, doc := range docs </span><span class="cov8" title="1">{
                // Check for _id field
                id, ok := doc.Get("_id")
                if !ok </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                Type:        IssueTypeMissingID,
                                Severity:    "critical",
                                Collection:  coll.Name(),
                                Description: "Document missing _id field",
                                Details: map[string]interface{}{
                                        "document": doc,
                                },
                        })
                        continue</span>
                }

                // Validate _id is ObjectID (check both pointer and value types)
                <span class="cov8" title="1">_, isPointer := id.(*document.ObjectID)
                _, isValue := id.(document.ObjectID)
                if !isPointer &amp;&amp; !isValue </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                Type:        IssueTypeInvalidID,
                                Severity:    "warning",
                                Collection:  coll.Name(),
                                DocumentID:  fmt.Sprintf("%v", id),
                                Description: "Document _id is not an ObjectID",
                                Details: map[string]interface{}{
                                        "id_type": fmt.Sprintf("%T", id),
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">return issues, len(docs)</span>
}

// validateIndexes checks index integrity
func (v *Validator) validateIndexes(coll *database.Collection) ([]Issue, int) <span class="cov8" title="1">{
        issues := make([]Issue, 0)

        // Get all indexes (using ListIndexes which returns []map[string]interface{})
        indexList := coll.ListIndexes()

        // Note: With the current public API, we have limited access to index internals.
        // We perform basic validation:
        // 1. Check that indexes exist
        // 2. Validate index list is accessible

        // For each index, try a simple query to ensure it's functional
        for _, indexInfo := range indexList </span><span class="cov8" title="1">{
                indexName, ok := indexInfo["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip validating the _id index (it's always present)
                <span class="cov8" title="1">if indexName == "_id" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Basic validation: index exists and is accessible
                // More detailed validation would require access to internal index structures
        }

        <span class="cov8" title="1">return issues, len(indexList)</span>
}

// Note: validateIndexEntries has been removed as it required access to
// internal index structures which are not exposed through the public API.
// Index validation is now simplified to basic checks.

// Repairer performs database repairs
type Repairer struct {
        db        *database.Database
        validator *Validator
}

// NewRepairer creates a new repairer
func NewRepairer(db *database.Database) *Repairer <span class="cov8" title="1">{
        return &amp;Repairer{
                db:        db,
                validator: NewValidator(db),
        }
}</span>

// Repair performs repair operations based on validation issues
func (r *Repairer) Repair(options *RepairOptions) (*RepairReport, error) <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultRepairOptions()
        }</span>

        <span class="cov8" title="1">report := &amp;RepairReport{
                StartTime:    time.Now(),
                Issues:       make([]Issue, 0),
                FixedIssues:  make([]Issue, 0),
                FailedIssues: make([]Issue, 0),
        }

        // First, validate to find issues
        validationReport, err := r.validator.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">report.Issues = validationReport.Issues

        // If dry run, just return the issues
        if options.DryRun </span><span class="cov8" title="1">{
                report.EndTime = time.Now()
                return report, nil
        }</span>

        // Fix issues
        <span class="cov8" title="1">for _, issue := range validationReport.Issues </span><span class="cov0" title="0">{
                fixed := false

                switch issue.Type </span>{
                case IssueTypeMissingIndexEntry:<span class="cov0" title="0">
                        if options.AddMissingEntries </span><span class="cov0" title="0">{
                                fixed = r.fixMissingIndexEntry(issue)
                        }</span>
                case IssueTypeOrphanedIndexEntry:<span class="cov0" title="0">
                        if options.RemoveOrphans </span><span class="cov0" title="0">{
                                fixed = r.fixOrphanedIndexEntry(issue)
                        }</span>
                }

                <span class="cov0" title="0">if fixed </span><span class="cov0" title="0">{
                        report.Fixed++
                        report.FixedIssues = append(report.FixedIssues, issue)
                }</span> else<span class="cov0" title="0"> {
                        report.Failed++
                        report.FailedIssues = append(report.FailedIssues, issue)
                }</span>
        }

        // Rebuild indexes if requested
        <span class="cov8" title="1">if options.RebuildIndexes </span><span class="cov8" title="1">{
                for _, collName := range validationReport.Collections </span><span class="cov8" title="1">{
                        if err := r.rebuildCollectionIndexes(collName); err != nil </span><span class="cov0" title="0">{
                                report.Failed++
                        }</span> else<span class="cov8" title="1"> {
                                report.Fixed++
                        }</span>
                }
        }

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}

// RepairCollection repairs a specific collection
func (r *Repairer) RepairCollection(collectionName string, options *RepairOptions) (*RepairReport, error) <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultRepairOptions()
        }</span>

        <span class="cov8" title="1">report := &amp;RepairReport{
                StartTime:    time.Now(),
                Issues:       make([]Issue, 0),
                FixedIssues:  make([]Issue, 0),
                FailedIssues: make([]Issue, 0),
        }

        // Validate collection
        validationReport, err := r.validator.ValidateCollection(collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">report.Issues = validationReport.Issues

        // If dry run, just return the issues
        if options.DryRun </span><span class="cov8" title="1">{
                report.EndTime = time.Now()
                return report, nil
        }</span>

        // Rebuild indexes if requested
        <span class="cov8" title="1">if options.RebuildIndexes </span><span class="cov8" title="1">{
                if err := r.rebuildCollectionIndexes(collectionName); err != nil </span><span class="cov0" title="0">{
                        report.Failed++
                }</span> else<span class="cov8" title="1"> {
                        report.Fixed++
                }</span>
        }

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}

// fixMissingIndexEntry adds a missing index entry
func (r *Repairer) fixMissingIndexEntry(issue Issue) bool <span class="cov8" title="1">{
        // Implementation would update the index
        // This is a simplified version - actual implementation would need access to collection internals
        return false
}</span>

// fixOrphanedIndexEntry removes an orphaned index entry
func (r *Repairer) fixOrphanedIndexEntry(issue Issue) bool <span class="cov8" title="1">{
        // Implementation would remove from index
        // This is a simplified version
        return false
}</span>

// rebuildCollectionIndexes rebuilds all indexes for a collection
func (r *Repairer) rebuildCollectionIndexes(collectionName string) error <span class="cov8" title="1">{
        coll := r.db.Collection(collectionName)
        if coll == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("collection not found: %s", collectionName)
        }</span>

        // Get all indexes
        <span class="cov8" title="1">indexList := coll.ListIndexes()

        // Store index configurations
        type indexInfo struct {
                name   string
                unique bool
        }
        indexesToRebuild := make([]indexInfo, 0)

        for _, idxMap := range indexList </span><span class="cov8" title="1">{
                name, ok := idxMap["name"].(string)
                if !ok || name == "_id" </span><span class="cov0" title="0">{
                        continue</span> // Skip _id index
                }

                <span class="cov8" title="1">unique := false
                if u, ok := idxMap["unique"].(bool); ok </span><span class="cov8" title="1">{
                        unique = u
                }</span>

                <span class="cov8" title="1">indexesToRebuild = append(indexesToRebuild, indexInfo{
                        name:   name,
                        unique: unique,
                })</span>
        }

        // Drop all non-_id indexes
        <span class="cov8" title="1">for _, idx := range indexesToRebuild </span><span class="cov8" title="1">{
                coll.DropIndex(idx.name)
        }</span>

        // Recreate indexes (which will rebuild them from documents)
        // Note: We use simple field names. For compound/text/geo indexes,
        // this is a simplified approach that may not fully restore all index types
        <span class="cov8" title="1">for _, idx := range indexesToRebuild </span><span class="cov8" title="1">{
                if err := coll.CreateIndex(idx.name, idx.unique); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rebuild index %s: %w", idx.name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Summary returns a human-readable summary of the validation report
func (r *ValidationReport) Summary() string <span class="cov8" title="1">{
        if r.IsHealthy </span><span class="cov8" title="1">{
                return fmt.Sprintf("Database is healthy. Checked %d documents across %d collections with %d indexes.",
                        r.DocumentCount, len(r.Collections), r.IndexCount)
        }</span>

        <span class="cov8" title="1">criticalCount := 0
        warningCount := 0
        for _, issue := range r.Issues </span><span class="cov8" title="1">{
                if issue.Severity == "critical" </span><span class="cov8" title="1">{
                        criticalCount++
                }</span> else<span class="cov8" title="1"> if issue.Severity == "warning" </span><span class="cov8" title="1">{
                        warningCount++
                }</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("Found %d issues (%d critical, %d warnings) across %d collections",
                len(r.Issues), criticalCount, warningCount, len(r.Collections))</span>
}

// Summary returns a human-readable summary of the repair report
func (r *RepairReport) Summary() string <span class="cov8" title="1">{
        duration := r.EndTime.Sub(r.StartTime)
        return fmt.Sprintf("Repair completed in %v. Fixed %d issues, failed to fix %d issues.",
                duration, r.Fixed, r.Failed)
}</span>

// DefragmentationReport contains the results of a defragmentation operation
type DefragmentationReport struct {
        StartTime          time.Time
        EndTime            time.Time
        InitialFileSize    int64
        FinalFileSize      int64
        SpaceSaved         int64
        PagesCompacted     int
        FragmentationRatio float64 // Ratio of free pages to total pages before defrag
}

// Summary returns a human-readable summary of the defragmentation report
func (r *DefragmentationReport) Summary() string <span class="cov8" title="1">{
        duration := r.EndTime.Sub(r.StartTime)
        percentSaved := 0.0
        if r.InitialFileSize &gt; 0 </span><span class="cov8" title="1">{
                percentSaved = float64(r.SpaceSaved) / float64(r.InitialFileSize) * 100.0
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Defragmentation completed in %v. Compacted %d pages, saved %d bytes (%.2f%%), fragmentation reduced from %.2f%%",
                duration, r.PagesCompacted, r.SpaceSaved, percentSaved, r.FragmentationRatio*100.0)</span>
}

// Defragmenter performs database defragmentation
type Defragmenter struct {
        db *database.Database
}

// NewDefragmenter creates a new defragmenter
func NewDefragmenter(db *database.Database) *Defragmenter <span class="cov8" title="1">{
        return &amp;Defragmenter{
                db: db,
        }
}</span>

// Defragment performs database defragmentation
// This compacts the database by removing free pages and reorganizing data
// Note: This is a logical defragmentation at the collection level since
// the storage engine is primarily in-memory with WAL-based persistence
func (d *Defragmenter) Defragment() (*DefragmentationReport, error) <span class="cov8" title="1">{
        report := &amp;DefragmentationReport{
                StartTime: time.Now(),
        }

        // Get database stats before defragmentation
        stats := d.db.Stats()

        // Calculate initial metrics
        // Note: In the current implementation, documents are stored in memory,
        // so we track logical fragmentation based on collection statistics
        initialDocCount := int64(0)
        initialIndexCount := int64(0)

        collections := d.db.ListCollections()
        for _, collName := range collections </span><span class="cov8" title="1">{
                coll := d.db.Collection(collName)
                if coll == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">collStats := coll.Stats()
                if docCount, ok := collStats["document_count"].(int); ok </span><span class="cov0" title="0">{
                        initialDocCount += int64(docCount)
                }</span>
                <span class="cov8" title="1">if indexCount, ok := collStats["index_count"].(int); ok </span><span class="cov8" title="1">{
                        initialIndexCount += int64(indexCount)
                }</span>
        }

        // Estimate initial file size based on document and index counts
        // This is a rough estimate: each document ~1KB, each index entry ~100 bytes
        <span class="cov8" title="1">report.InitialFileSize = (initialDocCount * 1024) + (initialIndexCount * 100)

        // Calculate fragmentation ratio from database stats
        if totalPages, ok := stats["total_pages"].(int64); ok </span><span class="cov0" title="0">{
                if freePages, ok := stats["free_pages"].(int64); ok </span><span class="cov0" title="0">{
                        if totalPages &gt; 0 </span><span class="cov0" title="0">{
                                report.FragmentationRatio = float64(freePages) / float64(totalPages)
                        }</span>
                }
        }

        // Perform defragmentation by rebuilding indexes
        // This removes orphaned index entries and rebuilds index structures compactly
        <span class="cov8" title="1">pagesCompacted := 0
        for _, collName := range collections </span><span class="cov8" title="1">{
                coll := d.db.Collection(collName)
                if coll == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get all indexes
                <span class="cov8" title="1">indexList := coll.ListIndexes()

                // Store index configurations
                type indexConfig struct {
                        name   string
                        unique bool
                }
                indexesToRebuild := make([]indexConfig, 0)

                for _, idxMap := range indexList </span><span class="cov8" title="1">{
                        name, ok := idxMap["name"].(string)
                        if !ok || name == "_id" </span><span class="cov0" title="0">{
                                continue</span> // Skip _id index
                        }

                        <span class="cov8" title="1">unique := false
                        if u, ok := idxMap["unique"].(bool); ok </span><span class="cov8" title="1">{
                                unique = u
                        }</span>

                        <span class="cov8" title="1">indexesToRebuild = append(indexesToRebuild, indexConfig{
                                name:   name,
                                unique: unique,
                        })</span>
                }

                // Rebuild each index
                <span class="cov8" title="1">for _, idx := range indexesToRebuild </span><span class="cov8" title="1">{
                        // Drop the index
                        coll.DropIndex(idx.name)

                        // Recreate it (which rebuilds from scratch, compacting the structure)
                        if err := coll.CreateIndex(idx.name, idx.unique); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to rebuild index %s: %w", idx.name, err)
                        }</span>

                        <span class="cov8" title="1">pagesCompacted++</span>
                }
        }

        <span class="cov8" title="1">report.PagesCompacted = pagesCompacted

        // Calculate final metrics
        finalDocCount := int64(0)
        finalIndexCount := int64(0)

        for _, collName := range collections </span><span class="cov8" title="1">{
                coll := d.db.Collection(collName)
                if coll == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">collStats := coll.Stats()
                if docCount, ok := collStats["document_count"].(int); ok </span><span class="cov0" title="0">{
                        finalDocCount += int64(docCount)
                }</span>
                <span class="cov8" title="1">if indexCount, ok := collStats["index_count"].(int); ok </span><span class="cov8" title="1">{
                        finalIndexCount += int64(indexCount)
                }</span>
        }

        // Estimate final file size
        <span class="cov8" title="1">report.FinalFileSize = (finalDocCount * 1024) + (finalIndexCount * 100)

        // Calculate space saved
        if report.FinalFileSize &lt; report.InitialFileSize </span><span class="cov0" title="0">{
                report.SpaceSaved = report.InitialFileSize - report.FinalFileSize
        }</span>

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}

// DefragmentCollection performs defragmentation on a specific collection
func (d *Defragmenter) DefragmentCollection(collectionName string) (*DefragmentationReport, error) <span class="cov8" title="1">{
        report := &amp;DefragmentationReport{
                StartTime: time.Now(),
        }

        coll := d.db.Collection(collectionName)
        if coll == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collection not found: %s", collectionName)
        }</span>

        // Get collection stats before defragmentation
        <span class="cov8" title="1">collStats := coll.Stats()
        initialDocCount := int64(0)
        initialIndexCount := int64(0)

        if docCount, ok := collStats["document_count"].(int); ok </span><span class="cov0" title="0">{
                initialDocCount = int64(docCount)
        }</span>
        <span class="cov8" title="1">if indexCount, ok := collStats["index_count"].(int); ok </span><span class="cov8" title="1">{
                initialIndexCount = int64(indexCount)
        }</span>

        <span class="cov8" title="1">report.InitialFileSize = (initialDocCount * 1024) + (initialIndexCount * 100)

        // Get all indexes
        indexList := coll.ListIndexes()

        // Store index configurations
        type indexConfig struct {
                name   string
                unique bool
        }
        indexesToRebuild := make([]indexConfig, 0)

        for _, idxMap := range indexList </span><span class="cov8" title="1">{
                name, ok := idxMap["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip _id index (both "_id" field name and "_id_" index name)
                <span class="cov8" title="1">if name == "_id" || name == "_id_" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">unique := false
                if u, ok := idxMap["unique"].(bool); ok </span><span class="cov8" title="1">{
                        unique = u
                }</span>

                <span class="cov8" title="1">indexesToRebuild = append(indexesToRebuild, indexConfig{
                        name:   name,
                        unique: unique,
                })</span>
        }

        // Rebuild each index
        <span class="cov8" title="1">pagesCompacted := 0
        for _, idx := range indexesToRebuild </span><span class="cov8" title="1">{
                // Drop the index
                coll.DropIndex(idx.name)

                // Recreate it (which rebuilds from scratch, compacting the structure)
                if err := coll.CreateIndex(idx.name, idx.unique); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to rebuild index %s: %w", idx.name, err)
                }</span>

                <span class="cov8" title="1">pagesCompacted++</span>
        }

        <span class="cov8" title="1">report.PagesCompacted = pagesCompacted

        // Get final stats
        collStats = coll.Stats()
        finalDocCount := int64(0)
        finalIndexCount := int64(0)

        if docCount, ok := collStats["document_count"].(int); ok </span><span class="cov0" title="0">{
                finalDocCount = int64(docCount)
        }</span>
        <span class="cov8" title="1">if indexCount, ok := collStats["index_count"].(int); ok </span><span class="cov8" title="1">{
                finalIndexCount = int64(indexCount)
        }</span>

        <span class="cov8" title="1">report.FinalFileSize = (finalDocCount * 1024) + (finalIndexCount * 100)

        if report.FinalFileSize &lt; report.InitialFileSize </span><span class="cov0" title="0">{
                report.SpaceSaved = report.InitialFileSize - report.FinalFileSize
        }</span>

        <span class="cov8" title="1">report.EndTime = time.Now()
        return report, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
